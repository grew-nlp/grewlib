(* open Ast *)

(* module Checker = struct *)

(* 	exception Module_already_defined of (string*(string*int)) *)
(* 	exception Rule_already_defined of (string*string*(string*int)) *)
(* 	exception Invalid_feature of (string*(string*int)*string*(string*int)*string*(string*int)*string*string*int) *)
(* 	exception Node_already_defined of (string*(string*int)*string*(string*int)*string*(string*int)) *)
(* 	exception Node_already_defined_in_graph of (string*(string*int)) *)
(* 	exception Index_already_defined_in_graph of (string*(string*int)) *)
(* 	exception Edge_already_defined_in_graph of (string*string*(string*int)) *)
(* 	exception Edge_already_defined of (string*(string*int)*string*(string*int)*string*(string*int)) *)
(* 	exception Node_not_defined of (string*(string*int)*string*(string*int)*string option*(string*int)*string) *)
(* 	exception Unavailable_label of (string*(string*int)*string*(string*int)*string option*(string*int)*string) *)
(* 	exception Forbidden_label of (string*(string*int)*string*(string*int)*string option*(string*int)*string) *)
(* 	exception Undefined_module of (string*(string*int)*string) *)

(* 	let check_for_doublon_module ast = *)
(* 		let modules = List.map (fun m -> m.Ast.id) ast.Ast.modules in *)
(* 		let modules_trace = List.map (fun m -> m.Ast.mod_trace) ast.Ast.modules in *)
(* 		let rec compute tabA tabB = match tabA,tabB with *)
(* 			| ([],[]) -> () *)
(* 			| (h::t,h2::t2) -> if (List.mem h t) then (raise (Module_already_defined (h,h2))) else (compute t t2) *)
(* 			| _ -> failwith "Checker.check_for_doublon_module" *)
(* 		in compute (List.rev modules) (List.rev modules_trace) *)

(* 	let check_for_doublon_rule m =  *)
(* 		let rules = List.map (fun r -> r.Ast.rule_id) m.Ast.rules in *)
(* 		let rules_trace = List.map (fun r -> r.Ast.rule_trace) m.Ast.rules in *)
(* 		let rec compute tabA tabB = match tabA,tabB with *)
(* 			| ([],[]) -> () *)
(* 			| (h::t,h2::t2) -> if (List.mem h t) then (raise (Rule_already_defined (m.Ast.id,h,h2))) else (compute t t2) *)
(* 			| _ -> failwith "Checker.check_for_doublon_rule" *)
(* 		in compute (List.rev rules) (List.rev rules_trace) *)


(* 	let check_for_doublon_rule_inside_module ast =  *)
(* 		List.iter (fun m -> *)
(* 			check_for_doublon_rule m *)
(* 		) ast.Ast.modules *)
		
		
		
(* 	let check_for_doublon_node_inside_pattern ast = failwith "FIXME check_for_doublon_node_inside_pattern" *)
(* 		(\* List.iter (fun m -> *\) *)
(* 		(\* 	let rules = m.Ast.rules in *\) *)
(* 		(\* 	let rec compute tabA = match tabA with *\) *)
(* 		(\* 		| [] -> () *\) *)
(* 		(\* 		| h::t ->  *\) *)
(* 		(\* 			begin let rec compute tabA tabB = match tabA,tabB with *\) *)
(* 		(\* 				| ([],[]) -> () *\) *)
(* 		(\* 				| (id::t),(trace::tt) ->  *\) *)
(* 		(\* 					if (List.mem id t) then ( *\) *)
(* 		(\* 						raise (Node_already_defined (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,id,trace)) *\) *)
(* 		(\* 					) else ( *\) *)
(* 		(\* 						compute t tt *\) *)
(* 		(\* 					) *\) *)
(* 		(\* 				| _ -> failwith "Checker.check_for_doublon_node_inside_pattern" *\) *)
(* 		(\* 			in compute (List.rev (List.map (fun (id,_,_,_) -> id) h.Ast.pattern.pattern_nodes)) (List.rev (List.map (fun (_,_,_,(file,line)) -> (file,line)) h.Ast.pattern.pattern_nodes)) *\) *)
(* 		(\* 			end; *\) *)
(* 		(\* 			compute t *\) *)
(* 		(\* 	in compute rules  *\) *)
(* 		(\* ) ast.Ast.modules *\) *)

	
(* 	let rec is_available_feature name values domain = *)
(* 		match domain with *)
(* 			| [] -> false *)
(* 			| (Closed (n,v)) :: t -> *)
(* 				if (name=n) then ( *)
(* 					let rec compute tab = match tab with *)
(* 						| [] -> true *)
(* 						| h::t -> if (List.mem h v) then compute t else false *)
(* 					in  *)
(* 					compute values *)
(* 				) else (is_available_feature name values t) *)
(* 			| (Open n) :: t-> if (name=n) then true else (is_available_feature name values t) *)

(* 	let rec check_features modname modtrace rulename rtrace nodename ntrace features domain =  *)
(* 		match features with *)
(* 			| [] -> () *)
(* 			| (_,name,values,file,line)::t -> *)
(* 				if (not (is_available_feature name values domain)) then ( *)
(* 					raise (Invalid_feature (modname,modtrace,rulename,rtrace,nodename,ntrace,name,file,line)) *)
(* 				) else ( *)
(* 					check_features modname modtrace rulename rtrace nodename ntrace t domain *)
(* 				) *)

(* 	let check_features_inside_rules ast = failwith "FIXME check_features_inside_rules" *)
(* 		(\* List.iter (fun m -> *\) *)
(* 		(\* 	let rules = m.Ast.rules in *\) *)
(* 		(\* 	let rules_trace = List.map (fun r -> r.Ast.rule_trace) m.Ast.rules in *\) *)
(* 		(\* 	let rec compute tabA tabB = match tabA,tabB with *\) *)
(* 		(\* 		| ([],[]) -> () *\) *)
(* 		(\* 		| (h::t,h2::t2) ->  *\) *)
(* 		(\* 			begin let rec compute tab = match tab with *\) *)
(* 		(\* 				| [] -> () *\) *)
(* 		(\* 				| (id,_,node,ntrace)::t ->  *\) *)
(* 		(\* 					check_features m.Ast.id m.Ast.mod_trace h.Ast.rule_id h2 id ntrace node ast.Ast.domain; *\) *)
(* 		(\* 					compute t *\) *)
(* 		(\* 			in compute h.Ast.pattern.pattern_nodes *\) *)
(* 		(\* 			end; *\) *)
(* 		(\* 			compute t t2 *\) *)
(* 		(\* 		| _ -> failwith "Checker.check_features_inside_rules" *\) *)
(* 		(\* 	in compute rules rules_trace *\) *)
(* 		(\* ) ast.Ast.modules *\) *)


(* 	let rec is_available_node pattern_nodes node =  *)
(* 		match pattern_nodes with *)
(* 			| [] -> false *)
(* 			| (id,_,_,_)::t -> if (id = node) then true else is_available_node t node *)

(* 	let check_edges_pattern ast = failwith "FIXME" *)
(* 		(\* List.iter (fun m -> *\) *)
(* 		(\* 	let rules = m.Ast.rules in *\) *)
(* 		(\* 	let rec compute tabA = match tabA with *\) *)
(* 		(\* 		| [] -> () *\) *)
(* 		(\* 		| h::t ->  *\) *)
(* 		(\* 			begin let rec compute tabA tabB tabC = match tabA,tabB,tabC with *\) *)
(* 		(\* 				| ([],[],[]) -> () *\) *)
(* 		(\* 				| (id::t),(((n1,n2),labels)::ttt),(trace::tt) -> *\) *)
(* 		(\* 						if (id <> "" && List.mem id t) then ( *\) *)
(* 		(\* 							let rec compute tabA tabB = match tabA,tabB with *\) *)
(* 		(\* 								| [],[] -> failwith "error0 check_edges_pattern" *\) *)
(* 		(\* 								| h1::[],h2::[] -> if (h1=id) then (h1,h2) else failwith "error1 check_edges_pattern" *\) *)
(* 		(\* 								| h1::t1,h2::t2 -> if (h1=id) then (h1,h2) else compute t1 t2 *\) *)
(* 		(\* 								| _ -> failwith "error2 check_edges_pattern" *\) *)
(* 		(\* 							in let (id,trace) = compute t tt in *\) *)
(* 		(\* 							raise (Edge_already_defined (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,id,trace)) *\) *)
(* 		(\* 						) else ( *\) *)
(* 		(\* 							let rec compute2 tabA tabB tabC = match tabA,tabB,tabC with *\) *)
(* 		(\* 								| [],[],[] -> () *\) *)
(* 		(\* 								| ((n1',n2'),labels')::t1,(trace::tt),(id::t) ->  *\) *)
(* 		(\* 									if (n1=n1' && n2=n2' && (List.for_all (fun a -> List.mem a labels) labels')) then ( *\) *)
(* 		(\* 										raise (Edge_already_defined (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,(if id="" then (n1^"->"^n2) else id),trace)) *\) *)
(* 		(\* 									) else ( *\) *)
(* 		(\* 										compute2 t1 tt t *\) *)
(* 		(\* 									) *\) *)
(* 		(\* 								| _ -> failwith "error0 check_for_doublon_edge" *\) *)
(* 		(\* 							in compute2 ttt tt t ; *\) *)
(* 		(\* 							if (not (is_available_node h.Ast.pattern.pattern_nodes n1)) then ( *\) *)
(* 		(\* 								raise (Node_not_defined (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,(match id with "" -> None | _ -> Some id),trace,n1)) *\) *)
(* 		(\* 							) else if (not (is_available_node h.Ast.pattern.pattern_nodes n2)) then ( *\) *)
(* 		(\* 								raise (Node_not_defined (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,(match id with "" -> None | _ -> Some id),trace,n2)) *\) *)
(* 		(\* 							) else ( *\) *)
(* 		(\* 								let rec compute tab = match tab with *\) *)
(* 		(\* 									| [] -> () *\) *)
(* 		(\* 									| h2::t2 ->  *\) *)
(* 		(\* 										if (not (List.mem_assoc h2 (ast.Ast.labels@m.Ast.local_labels))) then ( *\) *)
(* 		(\* 											raise (Unavailable_label (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,(match id with "" -> None | _ -> Some id),trace,h2)) *\) *)
(* 		(\* 										) else if (List.mem h2 m.Ast.bad_labels) then ( *\) *)
(* 		(\* 											raise (Forbidden_label (m.Ast.id,m.Ast.mod_trace,h.Ast.rule_id,h.Ast.rule_trace,(match id with "" -> None | _ -> Some id),trace,h2)) *\) *)
(* 		(\* 										) else ( *\) *)
(* 		(\* 											compute t2 *\) *)
(* 		(\* 										) *\) *)
(* 		(\* 								in compute labels *\) *)
(* 		(\* 							) *\) *)
(* 		(\* 						); *\) *)
(* 		(\* 						compute t ttt tt *\) *)
(* 		(\* 				| _ -> failwith "check_edges_pattern0" *\) *)
(* 		(\* 			in compute (List.map (fun (id,_,_) ->  *\) *)
(* 		(\* 			  match id with Some id -> id | None -> "") h.Ast.pattern.pattern_edges)  *\) *)
(* 		(\* 			  (List.map (fun (_,edge,_) -> match edge with (n1,n2,_,labels) -> ((n1,n2),labels) ) h.Ast.pattern.pattern_edges) *\) *)
(* 		(\* 			  (List.map (fun (_,_,(file,line)) -> (file,line)) h.Ast.pattern.pattern_edges) *\) *)
(* 		(\* 			end; *\) *)
(* 		(\* 			compute t *\) *)
(* 		(\* 	in compute rules  *\) *)
(* 		(\* ) ast.Ast.modules *\) *)
		
(* 	let check_sequences ast = *)
(* 		let sequences = ast.Ast.sequences in *)
(* 		let ast_mods = List.map (fun m -> m.Ast.id) ast.Ast.modules in *)
(* 		List.iter ( fun s -> *)
(* 			let mods = s.Ast.seq_mod in *)
(* 			List.iter ( fun m -> *)
(* 				if (not (List.mem m ast_mods)) then ( *)
(* 					raise (Undefined_module (s.Ast.seq_name,s.Ast.seq_trace,m)); *)
(* 				) *)
(* 			) mods *)
(* 		) sequences *)

(* 	let check_grs ast =  *)
(* 		check_for_doublon_module ast; *)
(* 		check_for_doublon_rule_inside_module ast; *)
(* 		check_for_doublon_node_inside_pattern ast; *)
(* 		check_features_inside_rules ast; *)
(* 		check_edges_pattern ast; *)
(* 		check_sequences ast *)
		
		
(* 	let check_for_doublon_node ast =  *)
(* 		let rec compute tabA tabB = match tabA,tabB with *)
(* 			| ([],[]) -> () *)
(* 			| (id::t),(trace::tt) ->  *)
(* 				if (List.mem id t) then ( *)
(* 					raise (Node_already_defined_in_graph (id,trace)) *)
(* 				) else ( *)
(* 					compute t tt *)
(* 				) *)
(* 			| _ -> failwith "Checker.check_for_doublon_node" *)
(* 		in compute (List.rev (List.map (fun (id,_,_,_) -> id) ast.nodes)) (List.rev (List.map (fun (_,_,_,(file,line)) -> (file,line)) ast.nodes)) *)
		
(* 	let check_for_doublon_node_index ast =  *)
(* 		let rec compute tabA tabB = match tabA,tabB with *)
(* 			| ([],[]) -> true *)
(* 			| (id::t),(trace::tt) ->  *)
(* 				id<>(-1) && (compute t tt) *)
(* 			| _ -> failwith "Checker.check_for_doublon_node" *)
(* 		in  *)
(* 		let c = compute (List.rev (List.map (fun (_,id,_,_) -> match id with None -> -1 | Some id -> id) ast.nodes)) (List.rev (List.map (fun (_,_,_,(file,line)) -> (file,line)) ast.nodes)) in *)
(* 		if (c) then ( *)
(* 			let rec compute tabA tabB = match tabA,tabB with *)
(* 				| ([],[]) -> () *)
(* 				| (id::t),(trace::tt) ->  *)
(* 					if (List.mem id t) then ( *)
(* 						raise (Index_already_defined_in_graph (string_of_int id,trace)) *)
(* 					) else ( *)
(* 						compute t tt *)
(* 					) *)
(* 				| _ -> failwith "Checker.check_for_doublon_node" *)
(* 			in compute (List.rev (List.map (fun (_,id,_,_) -> match id with None -> -1 | Some id -> id) ast.nodes)) (List.rev (List.map (fun (_,_,_,(file,line)) -> (file,line)) ast.nodes)) *)
(* 		) *)
		
(* 	let check_for_doublon_edge ast =  *)
(* 		let rec compute tabB tabC = match tabB,tabC with *)
(* 			| ([],[]) -> () *)
(* 			| (((n1,n2),labels)::ttt),(trace::tt) -> *)
(* 				let rec compute2 tabA tabB= match tabA,tabB with *)
(* 					| [],[] -> () *)
(* 					| ((n1',n2'),labels')::t1,(trace::tt) ->  *)
(* 						if (n1=n1' && n2=n2' && (List.for_all (fun a -> List.mem a labels) labels')) then ( *)
(* 							raise (Edge_already_defined_in_graph (n1,n2,trace)) *)
(* 						) else ( *)
(* 							compute2 t1 tt *)
(* 						) *)
(* 					| _ -> failwith "error0 check_for_doublon_edge" *)
(* 				in compute2 ttt tt ; *)
(* 				compute ttt tt; *)
(* 			| _ -> failwith "error1 check_for_doublon_edge" *)
(* 		in compute (List.map (fun (_,edge,_) -> match edge with (n1,n2,_,labels) -> ((n1,n2),labels) ) ast.edges) (List.map (fun (_,_,(file,line)) -> (file,line)) ast.edges) *)
		
(* 	let check_gr ast = *)
(* 		check_for_doublon_node ast; *)
(* 		check_for_doublon_node_index ast; *)
(* 		check_for_doublon_edge ast *)

(* end *)
